const path = require('path');
const fs = require('fs-extra');

/**
 * Bridge pour utiliser AliasManager existant dans l'interface Electron
 * Pointe vers le code existant dans ../AliasManager
 */
class AliasManager {
  constructor() {
    // Chemin vers AliasManager existant
    this.aliasManagerPath = path.join(__dirname, '../../../AliasManager');
    this.dataDir = path.join(this.aliasManagerPath, 'data');
    this.configDir = path.join(this.aliasManagerPath, 'configs');
    this.dataFile = path.join(this.dataDir, 'aliases.json');
    this.aliasFile = path.join(this.dataDir, 'aliases.sh');
    this.syncFile = path.join(this.configDir, 'sync.json');

    try {
      fs.ensureDirSync(this.dataDir);
      fs.ensureDirSync(this.configDir);
    } catch (error) {
      console.error('Erreur lors de la création des dossiers:', error);
      throw new Error("Impossible d'initialiser AliasManager. Vérifiez les permissions.");
    }
  }

  loadData() {
    try {
      if (!fs.existsSync(this.dataFile)) {
        const defaultData = { groups: { default: {} } };
        this.saveData(defaultData);
        return defaultData;
      }

      const data = fs.readJsonSync(this.dataFile);
      return this.validateData(data) ? data : { groups: { default: {} } };
    } catch (error) {
      console.error('Erreur lors du chargement des données:', error);
      return { groups: { default: {} } };
    }
  }

  saveData(data) {
    try {
      fs.writeJsonSync(this.dataFile, data, { spaces: 2 });
    } catch (error) {
      console.error('Erreur lors de la sauvegarde:', error);
      throw error;
    }
  }

  validateData(data) {
    return data && typeof data === 'object' && data.groups && typeof data.groups === 'object';
  }

  generateAliasFile(data) {
    try {
      let content = '# Generated by alias-manager\n\n';

      Object.entries(data.groups || {}).forEach(([groupName, group]) => {
        content += `# Group: ${groupName}\n`;

        Object.entries(group).forEach(([aliasName, alias]) => {
          if (alias.disabled) {
            content += `# ${aliasName} is disabled\n`;
          } else {
            const escapedCmd = alias.cmd.replace(/'/g, "'\"'\"'");
            content += `alias ${aliasName}='${escapedCmd}'\n`;
          }
        });

        content += '\n';
      });

      fs.writeFileSync(this.aliasFile, content);
    } catch (error) {
      console.error('Erreur lors de la génération du fichier alias:', error);
      throw error;
    }
  }

  validateAliasName(name) {
    if (!name || typeof name !== 'string') {
      throw new Error("Le nom de l'alias est requis et doit être une chaîne.");
    }

    if (!/^[a-zA-Z0-9_-]+$/.test(name)) {
      throw new Error(
        "Le nom de l'alias ne peut contenir que des lettres, chiffres, traits d'union et underscores."
      );
    }

    if (/^\d/.test(name)) {
      throw new Error("Le nom de l'alias ne peut pas commencer par un chiffre.");
    }

    if (name.length > 50) {
      throw new Error("Le nom de l'alias ne peut pas dépasser 50 caractères.");
    }

    const systemCommands = [
      'cd', 'ls', 'cp', 'mv', 'rm', 'mkdir', 'rmdir', 'pwd', 'cat', 'grep', 'find',
      'chmod', 'chown', 'sudo', 'ssh', 'git', 'curl', 'wget', 'tar', 'zip', 'unzip',
      'ps', 'kill', 'killall', 'top', 'htop', 'df', 'du', 'mount', 'umount',
      'systemctl', 'service', 'crontab', 'history', 'which', 'whereis', 'man',
      'echo', 'printf', 'sort', 'uniq', 'wc', 'head', 'tail', 'less', 'more',
      'awk', 'sed', 'tr', 'cut', 'paste', 'join', 'split',
    ];

    if (systemCommands.includes(name)) {
      throw new Error(`L'alias '${name}' entre en conflit avec une commande système critique.`);
    }
  }

  validateCommand(command) {
    if (!command || typeof command !== 'string') {
      throw new Error('La commande est requise et doit être une chaîne.');
    }

    if (command.trim().length === 0) {
      throw new Error('La commande ne peut pas être vide.');
    }

    if (command.length > 1000) {
      throw new Error('La commande ne peut pas dépasser 1000 caractères.');
    }
  }

  validateGroupName(groupName) {
    if (!groupName || typeof groupName !== 'string') {
      throw new Error('Le nom du groupe est requis et doit être une chaîne.');
    }

    if (!/^[a-zA-Z0-9_-]+$/.test(groupName)) {
      throw new Error(
        "Le nom du groupe ne peut contenir que des lettres, chiffres, traits d'union et underscores."
      );
    }

    if (groupName.length > 30) {
      throw new Error('Le nom du groupe ne peut pas dépasser 30 caractères.');
    }
  }

  async syncWithGit(action, details) {
    try {
      const data = this.loadData();
      fs.writeJsonSync(this.syncFile, data, { spaces: 2 });

      const { execSync } = require('child_process');
      const gitCommands = [
        `cd "${this.aliasManagerPath}" && git add configs/sync.json`,
        `cd "${this.aliasManagerPath}" && git commit -m "${action}: ${details}"`,
        `cd "${this.aliasManagerPath}" && git push`,
      ];

      for (const cmd of gitCommands) {
        try {
          execSync(cmd, { stdio: 'pipe' });
        } catch (gitError) {
          console.warn('Git sync warning (non-blocking):', gitError.message);
          break;
        }
      }
    } catch (error) {
      console.warn('Sync Git échoué (non bloquant):', error.message);
    }
  }

  async getAllAliases() {
    try {
      const data = this.loadData();
      return data.groups || {};
    } catch (error) {
      console.error('Erreur getAllAliases:', error);
      throw error;
    }
  }

  async getGroups() {
    try {
      const data = this.loadData();
      return Object.keys(data.groups || {});
    } catch (error) {
      console.error('Erreur getGroups:', error);
      throw error;
    }
  }

  async addAlias(name, command, group = 'default') {
    try {
      this.validateAliasName(name);
      this.validateCommand(command);
      this.validateGroupName(group);

      const data = this.loadData();

      if (data.groups[group] && data.groups[group][name]) {
        throw new Error(`L'alias '${name}' existe déjà dans le groupe '${group}'.`);
      }

      if (!data.groups[group]) {
        data.groups[group] = {};
      }

      data.groups[group][name] = {
        cmd: command,
        disabled: false,
      };

      this.saveData(data);
      this.generateAliasFile(data);

      await this.syncWithGit('feat', `add alias ${name} to group ${group}`);

      return { success: true, message: `Alias '${name}' ajouté dans le groupe '${group}'.` };
    } catch (error) {
      console.error('Erreur addAlias:', error);
      throw error;
    }
  }

  async updateAlias(oldName, newName, command, group = 'default') {
    try {
      this.validateAliasName(newName);
      this.validateCommand(command);
      this.validateGroupName(group);

      const data = this.loadData();

      if (!data.groups[group] || !data.groups[group][oldName]) {
        throw new Error(`L'alias '${oldName}' n'existe pas dans le groupe '${group}'.`);
      }

      if (newName !== oldName && data.groups[group][newName]) {
        throw new Error(`L'alias '${newName}' existe déjà dans le groupe '${group}'.`);
      }

      const wasDisabled = data.groups[group][oldName].disabled;

      if (newName !== oldName) {
        delete data.groups[group][oldName];
      }

      data.groups[group][newName] = {
        cmd: command,
        disabled: wasDisabled,
      };

      this.saveData(data);
      this.generateAliasFile(data);

      const action = newName !== oldName ? 'rename' : 'update';
      await this.syncWithGit(action, `${action} alias ${oldName} to ${newName} in group ${group}`);

      return {
        success: true,
        message: `Alias mis à jour: '${newName}' dans le groupe '${group}'.`,
      };
    } catch (error) {
      console.error('Erreur updateAlias:', error);
      throw error;
    }
  }

  async removeAlias(name, group = 'default') {
    try {
      const data = this.loadData();

      if (!data.groups[group] || !data.groups[group][name]) {
        throw new Error(`L'alias '${name}' n'existe pas dans le groupe '${group}'.`);
      }

      delete data.groups[group][name];

      if (Object.keys(data.groups[group]).length === 0) {
        delete data.groups[group];
      }

      this.saveData(data);
      this.generateAliasFile(data);

      await this.syncWithGit('remove', `remove alias ${name} from group ${group}`);

      return { success: true, message: `Alias '${name}' supprimé du groupe '${group}'.` };
    } catch (error) {
      console.error('Erreur removeAlias:', error);
      throw error;
    }
  }

  async toggleAlias(name, group = 'default', disabled) {
    try {
      const data = this.loadData();

      if (!data.groups[group] || !data.groups[group][name]) {
        throw new Error(`L'alias '${name}' n'existe pas dans le groupe '${group}'.`);
      }

      data.groups[group][name].disabled = disabled;

      this.saveData(data);
      this.generateAliasFile(data);

      const action = disabled ? 'disable' : 'enable';
      await this.syncWithGit(action, `${action} alias ${name} in group ${group}`);

      const status = disabled ? 'désactivé' : 'activé';
      return { success: true, message: `Alias '${name}' ${status} dans le groupe '${group}'.` };
    } catch (error) {
      console.error('Erreur toggleAlias:', error);
      throw error;
    }
  }

  async updateAliasDescription(name, group = 'default', description) {
    try {
      const data = this.loadData();

      if (!data.groups[group] || !data.groups[group][name]) {
        throw new Error(`L'alias '${name}' n'existe pas dans le groupe '${group}'.`);
      }

      data.groups[group][name].description = description || undefined;

      this.saveData(data);
      this.generateAliasFile(data);

      await this.syncWithGit('update', `update description for alias ${name} in group ${group}`);

      return {
        success: true,
        message: `Description de l'alias '${name}' mise à jour avec succès.`,
      };
    } catch (error) {
      console.error('Erreur updateAliasDescription:', error);
      throw error;
    }
  }

  async createGroup(groupName) {
    try {
      this.validateGroupName(groupName);

      const data = this.loadData();

      if (data.groups[groupName]) {
        throw new Error(`Le groupe '${groupName}' existe déjà.`);
      }

      data.groups[groupName] = {};

      this.saveData(data);
      this.generateAliasFile(data);

      await this.syncWithGit('feat', `create group ${groupName}`);

      return { success: true, message: `Groupe '${groupName}' créé avec succès.` };
    } catch (error) {
      console.error('Erreur createGroup:', error);
      throw error;
    }
  }

  async renameGroup(oldName, newName) {
    try {
      this.validateGroupName(newName);

      const data = this.loadData();

      if (!data.groups[oldName]) {
        throw new Error(`Le groupe '${oldName}' n'existe pas.`);
      }

      if (data.groups[newName]) {
        throw new Error(`Le groupe '${newName}' existe déjà.`);
      }

      if (oldName === 'default') {
        throw new Error("Le groupe 'default' ne peut pas être renommé.");
      }

      data.groups[newName] = { ...data.groups[oldName] };
      delete data.groups[oldName];

      this.saveData(data);
      this.generateAliasFile(data);

      await this.syncWithGit('rename', `rename group ${oldName} to ${newName}`);

      return {
        success: true,
        message: `Groupe '${oldName}' renommé en '${newName}' avec succès.`,
        aliasCount: Object.keys(data.groups[newName]).length,
      };
    } catch (error) {
      console.error('Erreur renameGroup:', error);
      throw error;
    }
  }

  async deleteGroup(groupName, deleteAliases = false) {
    try {
      const data = this.loadData();

      if (!data.groups[groupName]) {
        throw new Error(`Le groupe '${groupName}' n'existe pas.`);
      }

      if (groupName === 'default') {
        throw new Error("Le groupe 'default' ne peut pas être supprimé.");
      }

      const aliasCount = Object.keys(data.groups[groupName]).length;
      const aliases = data.groups[groupName];

      if (deleteAliases) {
        delete data.groups[groupName];

        this.saveData(data);
        this.generateAliasFile(data);

        await this.syncWithGit('remove', `delete group ${groupName} with ${aliasCount} aliases`);

        return {
          success: true,
          message: `Groupe '${groupName}' supprimé définitivement avec ${aliasCount} alias(es).`,
          deletedAliasCount: aliasCount,
          transferredAliasCount: 0,
        };
      } else {
        if (!data.groups.default) {
          data.groups.default = {};
        }

        Object.keys(aliases).forEach((aliasName) => {
          data.groups.default[aliasName] = aliases[aliasName];
        });

        delete data.groups[groupName];

        this.saveData(data);
        this.generateAliasFile(data);

        await this.syncWithGit(
          'remove',
          `delete group ${groupName}, transfer ${aliasCount} aliases to default`
        );

        return {
          success: true,
          message: `Groupe '${groupName}' supprimé. ${aliasCount} alias(es) transféré(s) vers le groupe 'default'.`,
          deletedAliasCount: 0,
          transferredAliasCount: aliasCount,
        };
      }
    } catch (error) {
      console.error('Erreur deleteGroup:', error);
      throw error;
    }
  }

  async getGroupInfo(groupName) {
    try {
      const data = this.loadData();

      if (!data.groups[groupName]) {
        throw new Error(`Le groupe '${groupName}' n'existe pas.`);
      }

      const group = data.groups[groupName];
      const aliases = Object.keys(group);
      const activeAliases = aliases.filter((name) => !group[name].disabled);
      const disabledAliases = aliases.filter((name) => group[name].disabled);

      return {
        name: groupName,
        aliasCount: aliases.length,
        activeCount: activeAliases.length,
        disabledCount: disabledAliases.length,
        aliases: group,
        isDeletable: groupName !== 'default',
        isRenamable: groupName !== 'default',
      };
    } catch (error) {
      console.error('Erreur getGroupInfo:', error);
      throw error;
    }
  }

  async getGroupsStats() {
    try {
      const data = this.loadData();
      const stats = [];

      Object.keys(data.groups).forEach((groupName) => {
        const group = data.groups[groupName];
        const aliases = Object.keys(group);
        const activeCount = aliases.filter((name) => !group[name].disabled).length;
        const disabledCount = aliases.filter((name) => group[name].disabled).length;

        stats.push({
          name: groupName,
          aliasCount: aliases.length,
          activeCount,
          disabledCount,
          isDeletable: groupName !== 'default',
          isRenamable: groupName !== 'default',
        });
      });

      stats.sort((a, b) => {
        if (a.name === 'default') return -1;
        if (b.name === 'default') return 1;
        return a.name.localeCompare(b.name);
      });

      return stats;
    } catch (error) {
      console.error('Erreur getGroupsStats:', error);
      throw error;
    }
  }
}

module.exports = { AliasManager };